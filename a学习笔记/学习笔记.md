## 环境初始化

设置淘宝镜像源:`npm config set registry https://registry.npmmirror.com`

1. 安装react:`npm create vite@latest react-lowcode --template react-ts`

2. 安装代码格式化校验:`npm install prettier eslint-config-prettier eslint-plugin-prettier --save-dev`

   * 再本地新建`.prettierrc.cjs`文件配置如下,配置完成后重启IDE

     ```js
     module.exports= {
       // 箭头函数只有一个参数的时候可以忽略括号
       arrowParens: "avoid",
       // 括号内部不要出现空格
       bracketSpacing: true,
       // 行结束符使用 Unix 格式
       endOfLine: "lf",
       // true: Put > on the last line instead of at a new line
       jsxBracketSameLine: false,
       // 行宽
       printWidth: 100,
       // 换行方式
       proseWrap: "preserve",
       // 分号
       semi: false,
       // 使用单引号
       singleQuote: true,
       // 缩进
       tabWidth: 2,
       // 使用 tab 缩进
       useTabs: false,
       // 后置逗号，多行对象、数组在最后一行增加逗号
       trailingComma: "es5",
       parser: "typescript",
     };
     
     ```

     

3. 安装`husky`代码提交校验工具

   * `npm i husky -D`

   * `npm pkg set scripts.prepare="husky install"` 添加`package.josn`执行脚本
   * `npx husky init`
   * `npx husky add .husky/pre-commit "npm run lint"` 添加钩子
   * `npx husky add .husky/pre-commit "npm run format"`

4. 安装`commitlint` 提交信息校验工具库

   * `npm install --save-dev @commitlint/config-conventional @commitlint/cli`

   * 安装`husky` 

   * 添加hook  `echo "npx --no -- commitlint --edit \$1" > .husky/commit-msg`

     * 之后提交代码遇到控制台报错:

       > commitlint + husky提示.husky/commit-msg: .husky/commit-msg: cannot execute binary

       网上查到原因是因为echo命令创建的文件的编码是UTF-16LE，所以手动去.husky目录创建`commit-msg`文件就没问题。

     ```
     build: 影响构建系统或外部依赖项的更改，例如更新了构建配置或者脚本文件。
     chore:添加了配置、辅助工具，不影响源代码 
     ci: 持续集成配置文件的更改，例如对CI服务器配置的更新或脚本的修改。
     docs: 文档文件的更改，例如更新了README、帮助文档或注释。
     perf: 性能优化，表示这个提交提高了代码的性能。
     refactor: 代码重构，表示对现有代码的结构进行了重构，但没有添加新功能或修复错误。
     revert: 撤销之前的提交，表示这个提交是用来撤销之前的某个提交的。
     *style: 代码风格更改，不影响代码逻辑的更改，比如格式化代码、缩进、空格等。
     *test: 测试相关的更改，比如增加了测试用例或修正了测试脚本。
     *feat: 新功能的添加，表示这是一个添加了新功能特性的提交。
     *fix: 错误修复，表示这是一个修复了某个问题的提交。
     ```

## useState特性	

- 任何state值更新都会触发 组件更新

  所以如果页面(jsx)中未使用一个变量那么不要使用`useState()`造成性能浪费，推荐使用`useRef()`

- count值为异步更新

- 闭包陷阱吗，异步获取state的值可能不是最新的 

- state是不可变的

  ```react
  //count不能直接修改值，要使用setCount()修改
  const [count ,setCount] = useState([id:1,name:'xxx'])	
  setCount(count.cantact({id:2,name:'ddd'}))
  
  //解决办法:安装immer
  import produce from 'immer'
  const [count ,setCount] = useState([id:1,name:'xxx'])
  setCount(produce(data=>{
      data.push({id:2,name:'ddd'})
  }))
  
  ```

- 会被合并执行

  ```react
  const [count ,setCount] = useState(1)	
  
  //只会执行一次
  setCount(1)
  setCount(1)
  setCount(1)
  setCount(1)
  //解决办法：
  //换成函数执行
  setCount(count=>count+1)
  setCount(count=>count+1)
  setCount(count=>count+1)
  
  ```

## useEffect

- 当组件完成渲染的时候

  **React18开始,useEffect会在开发环境执行俩次，目的是为了模拟组件创建、销毁、在创建的完整流程，及时暴露问题**

  生产环境就只会执行一次

- 当某个state值更新时候

## 其他内置Hook

### useRef

```react
//1.用于获取dom节点
const iptRef = useRef(null)
iptRef.current.select() //选中文本
<input ref={iptRef} />
//2.用于设置js变量，并且不会触发dom更新
const data = useRef('1')
data.current = 1

```

### useMemo

函数组件，每次state更新都会重新执行函数组件，useMemo可以缓存数据。不用每次执行函数都重新生成，用于计算量较大的场景。

类似于Vue的computed计算属性

```react
const [count1 ,setCount1] = useState(1)	
const [count2 ,setCount2] = useState(1)	
const sum = useMemo(()=>{
    return count1 + count2
},[count1,count2])
```

### useCallBack

用法和useMemo一致

 



